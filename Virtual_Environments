# -*- mode: shell-script -*-
#
# Modified version of Dough Hellmann's virtualenvwrapper
# http://www.doughellmann.com/projects/virtualenvwrapper/

# This copy is modified and redistributed as per — and continues to apply — Doug's license:

# Copyright Doug Hellmann, All Rights Reserved
#
# Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Doug Hellmann not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.

# DOUG HELLMANN DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DOUG HELLMANN BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#
# Shell functions to act as wrapper for Ian Bicking's virtualenv
# (http://pypi.python.org/pypi/virtualenv)
#

# Make sure there is a default value for WORKON_HOME.
# You can override this setting in your .bashrc.
# Note: in Alex's ZSH Environment, add a ~/.zsh.d/S99_WorkonHome file
# which just sets the WORKON_HOME environment variable.
if [ "$WORKON_HOME" = "" ] ; then
	if [ "$OSNAME" = 'Darwin' ] ; then
		WORKON_HOME=$HOME/Library/VirtualEnvironments
	else
		WORKON_HOME=$HOME/.virtualenvs
	fi
	export WORKON_HOME
fi

# Verify that the WORKON_HOME directory exists
function verify_workon_home () {
	if [ ! -d "$WORKON_HOME" ]
	then
		echo "ERROR: Virtual environments directory '$WORKON_HOME' does not exist."
		return 1
	fi
	return 0
}

# Verify that the requested environment exists
function verify_workon_environment () {
	typeset env_name="$1"
	if [ ! -d "$WORKON_HOME/$env_name" ]
	then
	   echo "ERROR: Environment '$env_name' does not exist. Create it with 'mkvirtualenv $env_name'."
	   return 1
	fi
	return 0
}

# Verify that the active environment exists
function verify_active_environment () {
	if [ ! -n "${VIRTUAL_ENV}" ] || [ ! -d "${VIRTUAL_ENV}" ]
	then
		echo "ERROR: no virtualenv active, or active virtualenv is missing"
		return 1
	fi
	return 0
}

# Print the last argument given to us.
# There has to be a smarter way to do this!
function _lastarg () {
	local a
	for a in "$@"
	do
		echo $a
	done | tail -1
}

# Create a new environment, in the WORKON_HOME.
#
# Usage: mkvirtualenv [options] ENVNAME
# (where the options are passed directly to virtualenv)
#
function mkvirtualenv () {
	verify_workon_home
	(cd "$WORKON_HOME"; virtualenv "$@")
	update_workon_tab_completion
	workon $(_lastarg "$@")
}

function configure_cpan {
	PERLENV=$1
	mkdir -p $PERLENV/lib/perl5/CPAN
	sed "s#@@VIRTUAL_ENV@@#$PERLENV#g" <<MYCONFIG > $PERLENV/lib/perl5/CPAN/MyConfig.pm
\$CPAN::Config = {
  'applypatch' => q[],
  'auto_commit' => q[0],
  'build_cache' => q[100],
  'build_dir' => q[@@VIRTUAL_ENV@@/.cpan/build],
  'build_dir_reuse' => q[1],
  'build_requires_install_policy' => q[yes],
  'bzip2' => q[/bin/bzip2],
  'cache_metadata' => q[1],
  'check_sigs' => q[0],
  'colorize_debug' => q[cyan],
  'colorize_output' => q[1],
  'colorize_print' => q[blue],
  'colorize_warn' => q[red],
  'commandnumber_in_prompt' => q[1],
  'cpan_home' => q[@@VIRTUAL_ENV@@/.cpan],
  'curl' => q[],
  'ftp' => q[/usr/bin/ftp],
  'ftp_passive' => q[1],
  'ftp_proxy' => q[],
  'getcwd' => q[cwd],
  'gpg' => q[/usr/bin/gpg],
  'gzip' => q[/bin/gzip],
  'histfile' => q[@@VIRTUAL_ENV@@/.cpan/histfile],
  'histsize' => q[100],
  'http_proxy' => q[],
  'inactivity_timeout' => q[0],
  'index_expire' => q[1],
  'inhibit_startup_message' => q[0],
  'keep_source_where' => q[@@VIRTUAL_ENV@@/.cpan/sources],
  'load_module_verbosity' => q[v],
  'lynx' => q[],
  'make' => q[/usr/bin/make],
  'make_arg' => q[],
  'make_install_arg' => q[],
  'make_install_make_command' => q[/usr/bin/make],
  'makepl_arg' => q[],
  'mbuild_arg' => q[],
  'mbuild_install_arg' => q[],
  'mbuild_install_build_command' => q[./Build],
  'mbuildpl_arg' => q[],
  'ncftp' => q[],
  'ncftpget' => q[],
  'no_proxy' => q[],
  'pager' => q[/usr/bin/less -MRS],
  'patch' => q[/usr/bin/patch],
  'prefer_installer' => q[MB],
  'prefs_dir' => q[@@VIRTUAL_ENV@@/.cpan/prefs],
  'prerequisites_policy' => q[follow],
  'scan_cache' => q[atstart],
  'shell' => q[/bin/bash],
  'show_unparsable_versions' => q[0],
  'show_upload_date' => q[0],
  'show_zero_versions' => q[0],
  'tar' => q[/bin/tar],
  'tar_verbosity' => q[v],
  'term_is_latin' => q[0],
  'term_ornaments' => q[1],
  'test_report' => q[0],
  'unzip' => q[],
  'urllist' => [q[ftp://mirror.internode.on.net/pub/cpan/], q[http://cpan.schools.net.au/]],
  'use_sqlite' => q[1],
  'wget' => q[/usr/bin/wget],
  'yaml_load_code' => q[0],
  'yaml_module' => q[YAML],
};

1;

__END__
MYCONFIG
}

function write_perlish_activate () {
	PERLENV=$1
	sed "s#@@VIRTUAL_ENV@@#$PERLENV#g" <<MYACTIVATE > $PERLENV/bin/activate
# This file must be used with "source bin/activate" *from bash*
# you cannot run it directly

deactivate () {
    # reset old environment variables
    if [ -n "\$_OLD_VIRTUAL_PATH" ] ; then
        PATH="\$_OLD_VIRTUAL_PATH"
        export PATH
        unset _OLD_VIRTUAL_PATH
    fi
    if [ -n "\$_OLD_VIRTUAL_PYTHONHOME" ] ; then
        PYTHONHOME="\$_OLD_VIRTUAL_PYTHONHOME"
        export PYTHONHOME
        unset _OLD_VIRTUAL_PYTHONHOME
    fi

    # This should detect bash and zsh, which have a hash command that must
    # be called to get it to forget past commands.  Without forgetting
    # past commands the \$PATH changes we made may not be respected
    if [ -n "\$BASH" -o -n "\$ZSH_VERSION" ] ; then
        hash -r
    fi

    if [ -n "\$_OLD_VIRTUAL_PS1" ] ; then
        PS1="\$_OLD_VIRTUAL_PS1"
        export PS1
        unset _OLD_VIRTUAL_PS1
    fi

    unset VIRTUAL_ENV
    unset PERLENV
    unset PERL5LIB
    unset MODULEBUILDRC
    unset PERL_MM_OPT
    unset PERL_MB_OPT
    if [ ! "\$1" = "nondestructive" ] ; then
    # Self destruct!
        unset -f deactivate
    fi
}

# unset irrelavent variables
deactivate nondestructive

VIRTUAL_ENV="@@VIRTUAL_ENV@@"
export VIRTUAL_ENV

_OLD_VIRTUAL_PATH="\$PATH"
PATH="\$VIRTUAL_ENV/bin:\$PATH"
PERLENV=\$VIRTUAL_ENV
eval \$(perl -I\${PERLENV}/lib/perl5 -Mlocal::lib=\${PERLENV})
export VIRTUAL_ENV PERLENV
export PATH

# unset PYTHONHOME if set
# this will fail if PYTHONHOME is set to the empty string (which is bad anyway)
# could use \`if (set -u; : \$PYTHONHOME) ;\` in bash
if [ -n "\$PYTHONHOME" ] ; then
    _OLD_VIRTUAL_PYTHONHOME="\$PYTHONHOME"
    unset PYTHONHOME
fi

if [ -z "\$VIRTUAL_ENV_DISABLE_PROMPT" ] ; then
    _OLD_VIRTUAL_PS1="\$PS1"
    if [ "x" != x ] ; then
	PS1="\$PS1"
    else
    if [ "\`basename \"\$VIRTUAL_ENV\"\`" = "__" ] ; then
        # special case for Aspen magic directories
        # see http://www.zetadev.com/software/aspen/
        PS1="[\`basename \\\`dirname \"\$VIRTUAL_ENV\"\\\`\`] \$PS1"
    else
        PS1="(\`basename \"\$VIRTUAL_ENV\"\`)\$PS1"
    fi
    fi
    export PS1
fi

# This should detect bash and zsh, which have a hash command that must
# be called to get it to forget past commands.  Without forgetting
# past commands the \$PATH changes we made may not be respected
if [ -n "\$BASH" -o -n "\$ZSH_VERSION" ] ; then
    hash -r
fi
MYACTIVATE
	}

function perlize_virtual_env () {
	[ -z "$VIRTUAL_ENV" ] && exit 1
	TARBALL_URL=http://search.cpan.org/CPAN/authors/id/G/GE/GETTY
	cd $VIRTUAL_ENV
	PERLENV=$VIRTUAL_ENV
	mkdir $VIRTUAL_ENV/bin
	mkdir $VIRTUAL_ENV/lib
	mkdir $VIRTUAL_ENV/include
	mkdir $VIRTUAL_ENV/man
	mkdir $VIRTUAL_ENV/.cpan
	write_perlish_activate $PERLENV
	configure_cpan $PERLENV
	PATH=$PERLENV/bin:$PATH
	export PERL5LIB=$PERLENV/lib/perl5:$PERL5LIB
	export PERL_MB_OPT="--install_base $PERLENV"
	export PERL_MM_OPT="INSTALL_BASE=$PERLENV"
	cd $PERLENV
	wget -O CHECKSUMS $TARBALL_URL/CHECKSUMS
	[ -f CHECKSUMS ] || exit
	PACKAGE_NAME=`grep "local-lib.*tar.gz" CHECKSUMS | sed 's#^.*\(local-lib-.*\.tar\.gz\).*$#\1#' | sort | tail -1`
	rm CHECKSUMS
	echo "Fetching $PACKAGE_NAME"
	wget -O local-lib.tar.gz "${TARBALL_URL}/${PACKAGE_NAME}"
	tar xzvf local-lib.tar.gz || exit
	cd local-lib-*
	[ -f Makefile.PL ] || exit 1
	perl Makefile.PL
	make test && make install
	cd ..
	rm -rf local-lib*
	source $PERLENV/bin/activate
	perlbin=`which perl`
	cat > ${PERLENV}/bin/perl << EOF
#!/bin/sh
PERLENV="${PERLENV}"
${perlbin} -I\$PERLENV/lib/perl5 -Mlocal::lib=\$PERLENV \$@
EOF
	chmod 755 $PERLENV/bin/perl
	rehash
	PERL_MM_USE_DEFAULT=1
	cpan DBI
	cpan CPAN::SQLite
	cpan Digest::SHA
	cpan Module::Build
	}

function mkperlvirtualenv () {
	eval "venv_name=\${$#}"
	echo $venv_name
	TARBALL_URL=http://search.cpan.org/CPAN/authors/id/G/GE/GETTY
	verify_workon_home
	(
		cd "$WORKON_HOME"
		virtualenv $@ || echo "virtualenv not installed"
		PERLENV="$WORKON_HOME/$venv_name"
		mkdir $venv_name
		mkdir $venv_name/bin
		mkdir $venv_name/lib
		mkdir $venv_name/include
		mkdir $venv_name/man
		mkdir $venv_name/.cpan
		write_perlish_activate $PERLENV
		configure_cpan $PERLENV
		PATH=$PERLENV/bin:$PATH
		export PERL5LIB=$PERLENV/lib/perl5:$PERL5LIB
		export PERL_MB_OPT="--install_base $PERLENV"
		export PERL_MM_OPT="INSTALL_BASE=$PERLENV"
		cd $PERLENV
		wget -O CHECKSUMS $TARBALL_URL/CHECKSUMS
		[ -f CHECKSUMS ] || exit
		PACKAGE_NAME=`grep "local-lib.*tar.gz" CHECKSUMS | sed 's#^.*\(local-lib-.*\.tar\.gz\).*$#\1#' | sort | tail -1`
		rm CHECKSUMS
		echo "Fetching $PACKAGE_NAME"
		wget -O local-lib.tar.gz "${TARBALL_URL}/${PACKAGE_NAME}"
		tar xzvf local-lib.tar.gz || exit
		cd local-lib-*
		[ -f Makefile.PL ] || exit 1
		perl Makefile.PL
		make test && make install
		cd ..
		rm -rf local-lib*
		source $PERLENV/bin/activate
		perlbin=`which perl`
		cat > ${PERLENV}/bin/perl << EOF
#!/bin/sh
PERLENV="${PERLENV}"
${perlbin} -I\$PERLENV/lib/perl5 -Mlocal::lib=\$PERLENV \$@
EOF
		chmod 755 $PERLENV/bin/perl
		rehash
	)
	update_workon_tab_completion
	workon $(_lastarg "$@")
	PERL_MM_USE_DEFAULT=1
	cpan DBI
	cpan CPAN::SQLite
	cpan Digest::SHA
	cpan Module::Build
}

# Remove an environment, in the WORKON_HOME.
function rmvirtualenv () {
	typeset env_name="$1"
	verify_workon_home
	if [ "$env_name" = "" ]
	then
		echo "Please specify an enviroment."
		return 1
	fi
	env_dir="$WORKON_HOME/$env_name"
	if [ "$VIRTUAL_ENV" = "$env_dir" ]
	then
		echo "ERROR: You cannot remove the active environment ('$env_name')."
		echo "Either switch to another environment, or run 'deactivate'."
		return 1
	fi
	rm -rf "$env_dir"
	update_workon_tab_completion
}

# List the available environments.
function show_workon_options () {
	verify_workon_home
	ls "$WORKON_HOME" | grep -v '*.egg' | sort
}

# List or change working virtual environments
#
# Usage: workon [environment_name]
#
function workon () {
	typeset env_name="$1"
	if [ "$env_name" = "" ]
	then
		show_workon_options
		return 1
	fi

	verify_workon_home || return 1
	verify_workon_environment $env_name || return 1
	
	activate="$WORKON_HOME/$env_name/bin/activate"
	if [ ! -f "$activate" ]
	then
		echo "ERROR: Environment '$WORKON_HOME/$env_name' does not contain an activate script."
		return 1
	fi
	
	if [ -f "$VIRTUAL_ENV/bin/predeactivate" ]
	then
		source "$VIRTUAL_ENV/bin/predeactivate"
	fi
	
	source "$activate"
	
	if [ -f "$VIRTUAL_ENV/bin/postactivate" ]
	then
		source "$VIRTUAL_ENV/bin/postactivate"
	fi
	return 0
}

#
# Set up tab completion.  (Adapted from Arthur Koziel's version at 
# http://arthurkoziel.com/2008/10/11/virtualenvwrapper-bash-completion/)
# 
function update_workon_tab_completion() {
	if [ -n "$BASH" ] ; then
		_virtualenvs ()
		{
			local cur="${COMP_WORDS[COMP_CWORD]}"
			COMPREPLY=( $(compgen -W "`show_workon_options`" -- ${cur}) )
		}

		complete -o default -o nospace -F _virtualenvs workon
		complete -o default -o nospace -F _virtualenvs rmvirtualenv
	elif [ -n "$ZSH_VERSION" ] ; then
		compctl -g "`show_workon_options`" workon rmvirtualenv
	fi
}
update_workon_tab_completion

# Path management for packages outside of the virtual env.
# Based on a contribution from James Bennett and Jannis Leidel.
#
# add2virtualenv directory1 directory2 ...
#
# Adds the specified directories to the Python path for the
# currently-active virtualenv. This will be done by placing the
# directory names in a path file named
# "virtualenv_path_extensions.pth" inside the virtualenv's
# site-packages directory; if this file does not exist, it will be
# created first.
#
function add2virtualenv () {

	verify_active_environment || return 1
	
	pyvers="`python -c 'import sys; print sys.version[:3]'`"
	site_packages="$VIRTUAL_ENV/lib/python${pyvers}/site-packages"
	
	if [ ! -d "${site_packages}" ]
	then
		echo "ERROR: currently-active virtualenv does not appear to have a site-packages directory"
		return 1
	fi

	path_file="$site_packages/virtualenv_path_extensions.pth"

	if [ "$*" = "" ]
	then
		echo "Usage: add2virtualenv dir [dir ...]"
		if [ -f "$path_file" ]
		then
			echo
			echo "Existing paths:"
			cat "$path_file"
		fi
		return 1
	fi

	touch "$path_file"
	for pydir in "$@"
	do
		echo "$pydir" >> "$path_file"
	done
	return 0
}
