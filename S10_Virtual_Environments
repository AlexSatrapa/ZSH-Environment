# -*- mode: shell-script -*-
#
# Modified version of Dough Hellmann's virtualenvwrapper
# http://www.doughellmann.com/projects/virtualenvwrapper/

# This copy is modified and redistributed as per — and continues to apply — Doug's license:

# Copyright Doug Hellmann, All Rights Reserved
#
# Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Doug Hellmann not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.

# DOUG HELLMANN DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DOUG HELLMANN BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#
# Shell functions to act as wrapper for Ian Bicking's virtualenv
# (http://pypi.python.org/pypi/virtualenv)
#

# Make sure there is a default value for WORKON_HOME.
# You can override this setting in your .bashrc.
if [ "$WORKON_HOME" = "" ] ; then
	if [ "$OSNAME" = 'Darwin' ] ; then
		WORKON_HOME=$HOME/Library/VirtualEnvironments
	else
		WORKON_HOME=$HOME/.virtualenvs
	fi
	export WORKON_HOME
fi

# Verify that the WORKON_HOME directory exists
function verify_workon_home () {
	if [ ! -d "$WORKON_HOME" ]
	then
		echo "ERROR: Virtual environments directory '$WORKON_HOME' does not exist."
		return 1
	fi
	return 0
}

# Verify that the requested environment exists
function verify_workon_environment () {
	typeset env_name="$1"
	if [ ! -d "$WORKON_HOME/$env_name" ]
	then
	   echo "ERROR: Environment '$env_name' does not exist. Create it with 'mkvirtualenv $env_name'."
	   return 1
	fi
	return 0
}

# Verify that the active environment exists
function verify_active_environment () {
	if [ ! -n "${VIRTUAL_ENV}" ] || [ ! -d "${VIRTUAL_ENV}" ]
	then
		echo "ERROR: no virtualenv active, or active virtualenv is missing"
		return 1
	fi
	return 0
}

# Print the last argument given to us.
# There has to be a smarter way to do this!
function _lastarg () {
	local a
	for a in "$@"
	do
		echo $a
	done | tail -1
}

# Create a new environment, in the WORKON_HOME.
#
# Usage: mkvirtualenv [options] ENVNAME
# (where the options are passed directly to virtualenv)
#
function mkvirtualenv () {
	verify_workon_home
	(cd "$WORKON_HOME"; virtualenv "$@")
	update_workon_tab_completion
	workon $(_lastarg "$@")
}

function insert_perlish {
        sed '/unset VIRTUAL_ENV/ a\
\    unset PERLENV\
\    unset PERL5LIB\
\    unset MODULEBUILDRC\
\    unset PERL_MM_OPT\
' $1 | sed '/PATH="$VIRTUAL_ENV\/bin:$PATH"/ a\
PERLENV=$VIRTUAL_ENV\
eval $(perl -I${PERLENV}/lib/perl5 -Mlocal::lib=${PERLENV} -MCPAN)\
export VIRTUAL_ENV PERLENV
' > /tmp/blah
mv /tmp/blah $1
}

function mkperlvirtualenv () {
	PERLENV="$WORKON_HOME/$1"
	TARBALL_URL=http://search.cpan.org/CPAN/authors/id/G/GE/GETTY
	verify_workon_home
	(
		cd "$WORKON_HOME"
		virtualenv "$@"
		cd $PERLENV
		wget -O CHECKSUMS $TARBALL_URL/CHECKSUMS
		[ -f CHECKSUMS ] || exit
		PACKAGE_NAME=`grep "local-lib.*tar.gz" CHECKSUMS | sed 's#^.*\(local-lib-.*\.tar\.gz\).*$#\1#' | sort | tail -1`
		rm CHECKSUMS
		echo "Fetching $PACKAGE_NAME"
		wget -O local-lib.tar.gz "${TARBALL_URL}/${PACKAGE_NAME}"
		tar xvf local-lib.tar.gz
		cd local-lib-*
		[ -f Makefile.PL ] || exit 1
		perl Makefile.PL --bootstrap="${PERLENV}"
		make test && make install
		cd ..
		rm -rf local-lib*
		insert_perlish $PERLENV/bin/activate
		perlbin=`which perl`
		cat > ${PERLENV}/bin/perl << EOF
#!/bin/sh
PERLENV="${PERLENV}"
${perlbin} -I\$PERLENV/lib/perl5 -Mlocal::lib=\$PERLENV -MCPAN \$@
EOF
		chmod 755 $PERLENV/bin/perl
		rehash
	)
	update_workon_tab_completion
	workon $(_lastarg "$@")
	cpan Module::Build
	cpan Digest::SHA
}

# Remove an environment, in the WORKON_HOME.
function rmvirtualenv () {
	typeset env_name="$1"
	verify_workon_home
	if [ "$env_name" = "" ]
	then
		echo "Please specify an enviroment."
		return 1
	fi
	env_dir="$WORKON_HOME/$env_name"
	if [ "$VIRTUAL_ENV" = "$env_dir" ]
	then
		echo "ERROR: You cannot remove the active environment ('$env_name')."
		echo "Either switch to another environment, or run 'deactivate'."
		return 1
	fi
	rm -rf "$env_dir"
	update_workon_tab_completion
}

# List the available environments.
function show_workon_options () {
	verify_workon_home
	ls "$WORKON_HOME" | egrep -v '*.egg' | sort
}

# List or change working virtual environments
#
# Usage: workon [environment_name]
#
function workon () {
	typeset env_name="$1"
	if [ "$env_name" = "" ]
	then
		show_workon_options
		return 1
	fi

	verify_workon_home || return 1
	verify_workon_environment $env_name || return 1
	
	activate="$WORKON_HOME/$env_name/bin/activate"
	if [ ! -f "$activate" ]
	then
		echo "ERROR: Environment '$WORKON_HOME/$env_name' does not contain an activate script."
		return 1
	fi
	
	if [ -f "$VIRTUAL_ENV/bin/predeactivate" ]
	then
		source "$VIRTUAL_ENV/bin/predeactivate"
	fi
	
	source "$activate"
	
	if [ -f "$VIRTUAL_ENV/bin/postactivate" ]
	then
		source "$VIRTUAL_ENV/bin/postactivate"
	fi
	return 0
}

#
# Set up tab completion.  (Adapted from Arthur Koziel's version at 
# http://arthurkoziel.com/2008/10/11/virtualenvwrapper-bash-completion/)
# 
function update_workon_tab_completion() {
	if [ -n "$BASH" ] ; then
		_virtualenvs ()
		{
			local cur="${COMP_WORDS[COMP_CWORD]}"
			COMPREPLY=( $(compgen -W "`show_workon_options`" -- ${cur}) )
		}

		complete -o default -o nospace -F _virtualenvs workon
		complete -o default -o nospace -F _virtualenvs rmvirtualenv
	elif [ -n "$ZSH_VERSION" ] ; then
		compctl -g "`show_workon_options`" workon rmvirtualenv
	fi
}
update_workon_tab_completion

# Path management for packages outside of the virtual env.
# Based on a contribution from James Bennett and Jannis Leidel.
#
# add2virtualenv directory1 directory2 ...
#
# Adds the specified directories to the Python path for the
# currently-active virtualenv. This will be done by placing the
# directory names in a path file named
# "virtualenv_path_extensions.pth" inside the virtualenv's
# site-packages directory; if this file does not exist, it will be
# created first.
#
function add2virtualenv () {

	verify_active_environment || return 1
	
	pyvers="`python -c 'import sys; print sys.version[:3]'`"
	site_packages="$VIRTUAL_ENV/lib/python${pyvers}/site-packages"
	
	if [ ! -d "${site_packages}" ]
	then
		echo "ERROR: currently-active virtualenv does not appear to have a site-packages directory"
		return 1
	fi

	path_file="$site_packages/virtualenv_path_extensions.pth"

	if [ "$*" = "" ]
	then
		echo "Usage: add2virtualenv dir [dir ...]"
		if [ -f "$path_file" ]
		then
			echo
			echo "Existing paths:"
			cat "$path_file"
		fi
		return 1
	fi

	touch "$path_file"
	for pydir in "$@"
	do
		echo "$pydir" >> "$path_file"
	done
	return 0
}
